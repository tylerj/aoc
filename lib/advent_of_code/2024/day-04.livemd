<!-- livebook:{"persist_outputs":true} -->

# Day 4 - Advent of Code 2024

```elixir
Mix.install([:kino, :benchee])
```

## Links

* [Advent of Code (AoC)](https://adventofcode.com/2024/day/4)
* [AoC Puzzle Input](https://adventofcode.com/2024/day/4/input)
* [tylerj GitHub - Livebook](https://github.com/tylerj/aoc/blob/main/lib/advent_of_code/2024/day-04.livemd)

## Prompt

### --- Day 4: Ceres Search ---

"Looks like the Chief's not here. Next!" One of The Historians pulls out a device and pushes the only button on it. After a brief flash, you recognize the interior of the [Ceres monitoring station](https://adventofcode.com/2019/day/10)!

As the search for the Chief continues, a small Elf who lives on the station tugs on your shirt; she'd like to know if you could help her with her **word search** (your puzzle input). She only has to find one word: `XMAS`.

This word search allows words to be horizontal, vertical, diagonal, written backwards, or even overlapping other words. It's a little unusual, though, as you don't merely need to find one instance of `XMAS` - you need to find **all of them**. Here are a few ways `XMAS` might appear, where irrelevant characters have been replaced with `.`:

```
..X...
.SAMX.
.A..A.
XMAS.S
.X....
```

The actual word search will be full of letters instead. For example:

```
MMMSXXMASM
MSAMXMSMSA
AMXSXMAAMM
MSAMASMSMX
XMASAMXAMM
XXAMMXXAMA
SMSMSASXSS
SAXAMASAAA
MAMMMXMMMM
MXMXAXMASX
```

In this word search, `XMAS` occurs a total of **18** times; here's the same word search again, but where letters not involved in any `XMAS` have been replaced with `.`:

```
....XXMAS.
.SAMXMS...
...S..A...
..A.A.MS.X
XMASAMX.MM
X.....XA.A
S.S.S.S.SS
.A.A.A.A.A
..M.M.M.MM
.X.X.XMASX
```

Take a look at the little Elf's word search. **How many times does XMAS appear?**

To begin, [get your puzzle input](https://adventofcode.com/2024/day/4/input).

<!-- livebook:{"break_markdown":true} -->

### --- Part Two ---

Part Two prompt

**QUESTION TWO?**

Although it hasn't changed, you can still [get your puzzle input](https://adventofcode.com/2024/day/4/input).

## Input

```elixir
input = Kino.Input.textarea("Please paste your input file:")
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
input = input |> Kino.Input.read()
# input = AdventOfCode.Input.get!(1, 2024)
```

<!-- livebook:{"output":true} -->

```
"MMMSXXMASM\nMSAMXMSMSA\nAMXSXMAAMM\nMSAMASMSMX\nXMASAMXAMM\nXXAMMXXAMA\nSMSMSASXSS\nSAXAMASAAA\nMAMMMXMMMM\nMXMXAXMASX"
```

## Solution

```elixir
defmodule Day04 do
  defdelegate parse(input), to: __MODULE__.Input

  def part1(input) do
    grid = parse(input)

    1..grid.max_y
    |> Enum.flat_map(fn y ->
      1..grid.max_x
      |> Enum.flat_map(fn x ->
        check_coord({x, y}, grid)
      end)
    end)
    |> Enum.sum()
  end

  def part2(input) do
    input
    |> parse()
  end

  defp check_coord(xy, grid) do
    check_coord(grid[xy], xy, grid)
  end

  defp check_coord(?X, xy, grid) do
    [
      next_coord(:NW, ?M, xy, grid),
      next_coord(:N, ?M, xy, grid),
      next_coord(:NE, ?M, xy, grid),
      next_coord(:E, ?M, xy, grid),
      next_coord(:SE, ?M, xy, grid),
      next_coord(:S, ?M, xy, grid),
      next_coord(:SW, ?M, xy, grid),
      next_coord(:W, ?M, xy, grid)
    ]
  end

  defp check_coord(_, _, _), do: [0]

  defp next_coord(dir, char, xy, grid) do
    xy = next_xy(dir, xy)

    case grid[xy] do
      ^char when char == ?S -> 1
      ^char -> next_coord(dir, next_char(char), xy, grid)
      _ -> 0
    end
  end

  defp next_char(?M), do: ?A
  defp next_char(?A), do: ?S

  defp next_xy(:NW, {x, y}), do: {x - 1, y - 1}
  defp next_xy(:N, {x, y}), do: {x, y - 1}
  defp next_xy(:NE, {x, y}), do: {x + 1, y - 1}
  defp next_xy(:E, {x, y}), do: {x + 1, y}
  defp next_xy(:SE, {x, y}), do: {x + 1, y + 1}
  defp next_xy(:S, {x, y}), do: {x, y + 1}
  defp next_xy(:SW, {x, y}), do: {x - 1, y + 1}
  defp next_xy(:W, {x, y}), do: {x - 1, y}

  defmodule Input do
    def parse(input) when is_binary(input) do
      input
      |> String.split("\n", trim: true)
      |> parse()
    end

    def parse(input) do
      grid = %{
        max_y: length(input),
        max_x: input |> List.first() |> String.length()
      }

      input
      |> Enum.with_index(1)
      |> Enum.reduce(grid, &parse_line/2)
    end

    def parse_line({line, y}, grid) do
      line
      |> String.to_charlist()
      |> Enum.with_index(1)
      |> Enum.reduce(grid, fn {c, x}, acc ->
        Map.put(acc, {x, y}, c)
      end)
    end
  end
end
```

<!-- livebook:{"output":true} -->

```
{:module, Day04, <<70, 79, 82, 49, 0, 0, 17, ...>>,
 {:module, Day04.Input, <<70, 79, 82, ...>>, {:parse_line, 2}}}
```

Take a look at the little Elf's word search. **How many times does XMAS appear?**

Your puzzle answer was `2613`.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Day04.part1(input)
```

<!-- livebook:{"output":true} -->

```
18
```

**QUESTION TWO?**

Your puzzle answer was `answer two`.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Day04.part2(input)
```

<!-- livebook:{"output":true} -->

```
%{
  {10, 6} => 65,
  {9, 8} => 65,
  {5, 10} => 65,
  {9, 4} => 77,
  {2, 7} => 77,
  {1, 7} => 83,
  {8, 8} => 65,
  {4, 6} => 77,
  {1, 4} => 77,
  {7, 10} => 77,
  {6, 1} => 88,
  {2, 8} => 65,
  {7, 2} => 83,
  {2, 2} => 83,
  {9, 9} => 77,
  {7, 3} => 65,
  {7, 7} => 83,
  {7, 6} => 88,
  {9, 7} => 83,
  {7, 1} => 77,
  {3, 1} => 77,
  {5, 7} => 83,
  {4, 5} => 83,
  {1, 5} => 88,
  {2, 4} => 83,
  {7, 5} => 88,
  {8, 10} => 65,
  {8, 1} => 65,
  {4, 10} => 88,
  {9, 5} => 77,
  {1, 10} => 77,
  {10, 9} => 77,
  {4, 1} => 83,
  {10, 8} => 65,
  {9, 6} => 77,
  {1, 1} => 77,
  {3, 7} => 83,
  {9, 2} => 83,
  {4, 3} => 83,
  {4, 7} => 77,
  {5, 1} => 88,
  {5, 9} => 77,
  {10, 3} => 77,
  {10, 5} => 77,
  {8, 7} => 88,
  {3, 4} => 65,
  {2, 1} => 77,
  {6, 4} => 83,
  {5, ...} => 65,
  {...} => 83,
  ...
}
```

Both parts of this puzzle are complete! They provide two gold stars: **

At this point, you should [return to your Advent calendar](https://adventofcode.com/2024) and try another puzzle.

If you still want to see it, you can [get your puzzle input](https://adventofcode.com/2024/day/4/input).

## Tests

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
ExUnit.start(auto_run: false)

defmodule Day04Test do
  use ExUnit.Case, async: false

  setup_all do
    [
      input:
        "MMMSXXMASM\nMSAMXMSMSA\nAMXSXMAAMM\nMSAMASMSMX\nXMASAMXAMM\nXXAMMXXAMA\nSMSMSASXSS\nSAXAMASAAA\nMAMMMXMMMM\nMXMXAXMASX"
    ]
  end

  describe "part1/1" do
    test "returns expected value", %{input: input} do
      assert Day04.part1(input) == 18
    end
  end

  describe "part2/1" do
    test "returns expected value", %{input: input} do
      assert Day04.part2(input) == [""]
    end
  end
end

ExUnit.run()
```

<!-- livebook:{"output":true} -->

```
.

  1) test part2/1 returns expected value (Day04Test)
     lib/advent_of_code/2024/day-04.livemd#cell:6u5vcz4asatsbiwxrh7hl3uu6guhkx3r:19
     Assertion with == failed
     code:  assert Day04.part2(input) == [""]
     left:  %{{10, 6} => 65, {9, 8} => 65, {5, 10} => 65, {9, 4} => 77, {2, 7} => 77, {1, 7} => 83, {8, 8} => 65, {4, 6} => 77, {1, 4} => 77, {7, 10} => 77, {6, 1} => 88, {2, 8} => 65, {7, 2} => 83, {2, 2} => 83, {9, 9} => 77, {7, 3} => 65, {7, 7} => 83, {7, 6} => 88, {9, 7} => 83, {7, 1} => 77, {3, 1} => 77, {5, 7} => 83, {4, 5} => 83, {1, 5} => 88, {2, 4} => 83, {7, 5} => 88, {8, 10} => 65, {8, 1} => 65, {4, 10} => 88, {9, 5} => 77, {1, 10} => 77, {10, 9} => 77, {4, 1} => 83, {10, 8} => 65, {9, 6} => 77, {1, 1} => 77, {3, 7} => 83, {9, 2} => 83, {4, 3} => 83, {4, 7} => 77, {5, 1} => 88, {5, 9} => 77, {10, 3} => 77, {10, 5} => 77, {8, 7} => 88, {3, 4} => 65, {2, 1} => 77, {6, 4} => 83, {5, ...} => 65, {...} => 83, ...}
     right: [""]
     stacktrace:
       lib/advent_of_code/2024/day-04.livemd#cell:6u5vcz4asatsbiwxrh7hl3uu6guhkx3r:20: (test)


Finished in 0.00 seconds (0.00s async, 0.00s sync)
2 tests, 1 failure

Randomized with seed 766654
```

<!-- livebook:{"output":true} -->

```
%{total: 2, failures: 1, excluded: 0, skipped: 0}
```

## Benchmarking

```elixir
defmodule Benchmarking do
  # https://github.com/bencheeorg/benchee
  def run(input) do
    Benchee.run(
      %{
        "Part 1" => fn -> Day04.part1(input) end,
        "Part 2" => fn -> Day04.part2(input) end
      },
      memory_time: 2,
      reduction_time: 2
    )

    nil
  end
end
```

<!-- livebook:{"output":true} -->

```

```

<!-- livebook:{"output":true} -->

```
nil
```

```elixir
Benchmarking.run(input)
```
