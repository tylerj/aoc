<!-- livebook:{"persist_outputs":true} -->

# Day 12 - Advent of Code 2023

```elixir
Mix.install([:kino, :benchee])
```

## Links

* [Advent of Code (AoC)](https://adventofcode.com/2023/day/12)
* [AoC Puzzle Input](https://adventofcode.com/2023/day/12/input)
* [tylerj GitHub - Livebook](https://github.com/tylerj/aoc/blob/main/lib/advent_of_code/2023/day-12.livemd)

## Input

```elixir
input = Kino.Input.textarea("Please paste your input file:")
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
input = input |> Kino.Input.read()
```

<!-- livebook:{"output":true} -->

```
"???.### 1,1,3\n.??..??...?##. 1,1,3\n?#?#?#?#?#?#?#? 1,3,1,6\n????.#...#... 4,1,1\n????.######..#####. 1,6,5\n?###???????? 3,2,1"
```

## Solution

```elixir
defmodule Day12 do
  defdelegate parse(input), to: __MODULE__.Input

  def part1(input) do
    input
    |> parse()
    |> Stream.map(&find_matches/1)
    |> Stream.map(&length/1)
    # |> Stream.with_index()
    # |> Stream.map(fn {matches, i} ->
    #   IO.inspect(length(matches), label: "LENGTH #{i}")
    #   length(matches)
    # end)
    |> Enum.sum()
  end

  def part2(input) do
    input
    |> parse()
    |> Stream.map(&expand/1)
    |> Stream.map(&find_matches/1)
    |> Stream.map(&length/1)
    # |> Stream.with_index()
    # |> Stream.map(fn {matches, i} ->
    #   IO.inspect(length(matches), label: "LENGTH #{i}")
    #   length(matches)
    # end)
    |> Enum.sum()
  end

  defp expand({line, sizes}) do
    {
      List.duplicate(String.to_charlist(line), 5) |> Enum.join("?"),
      List.duplicate(sizes, 5) |> List.flatten()
    }
  end

  def find_matches({line, sizes}) do
    find_matches(String.to_charlist(line), sizes_regex(sizes), true, [])
  end

  defp find_matches(_, _, false, _), do: []
  defp find_matches([], _regex, true, acc), do: [to_string(acc)]

  defp find_matches([?? | tail], regex, true, acc) do
    branch1 = List.insert_at(acc, -1, ?.)
    branch2 = List.insert_at(acc, -1, ?#)

    branch1_cont = Regex.match?(regex, to_string(branch1 ++ tail))
    branch2_cont = Regex.match?(regex, to_string(branch2 ++ tail))

    find_matches(tail, regex, branch1_cont, branch1) ++
      find_matches(tail, regex, branch2_cont, branch2)
  end

  defp find_matches([next_char | tail], regex, true, acc) do
    # cont = Regex.match?(regex, to_string(acc ++ tail))

    find_matches(tail, regex, true, List.insert_at(acc, -1, next_char))
  end

  def sizes_regex(sizes) do
    regex =
      sizes
      |> Enum.map(&"[\\?#]{#{&1}}")
      |> Enum.join("[\\?\\.]+")

    ~r/^[\.\?]*#{regex}[\.\?]*$/
  end

  defmodule Input do
    def parse(input) when is_binary(input) do
      input
      |> String.splitter("\n", trim: true)
      |> parse()
    end

    def parse(input) do
      Enum.map(input, &parse_line/1)
    end

    def parse_line(line) do
      [line, sizes] = String.split(line, " ", trim: true)
      sizes = sizes |> String.split(",", trim: true) |> Enum.map(&String.to_integer/1)

      {line, sizes}
    end
  end
end
```

<!-- livebook:{"output":true} -->

```
{:module, Day12, <<70, 79, 82, 49, 0, 0, 18, ...>>,
 {:module, Day12.Input, <<70, 79, 82, ...>>, {:parse_line, 1}}}
```

For each row, count all of the different arrangements of operational and broken springs that meet the given criteria. **What is the sum of those counts?**

Your puzzle answer was `answer one`.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Day12.part1(input)
```

<!-- livebook:{"output":true} -->

```
21
```

Unfold your condition records; **what is the new sum of possible arrangement counts?**

Your puzzle answer was `answer two`.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Day12.part2(input)
```

<!-- livebook:{"output":true} -->

```
525152
```

Both parts of this puzzle are complete! They provide two gold stars: **

At this point, you should [return to your Advent calendar](https://adventofcode.com/2023) and try another puzzle.

If you still want to see it, you can [get your puzzle input](https://adventofcode.com/2023/day/12/input).

## Tests

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
ExUnit.start(auto_run: false)

defmodule Day12Test do
  use ExUnit.Case, async: false

  setup_all do
    [
      input:
        "???.### 1,1,3\n.??..??...?##. 1,1,3\n?#?#?#?#?#?#?#? 1,3,1,6\n????.#...#... 4,1,1\n????.######..#####. 1,6,5\n?###???????? 3,2,1"
    ]
  end

  describe "part1/1" do
    test "returns expected value", %{input: input} do
      assert Day12.part1(input) == 21
    end
  end

  describe "part2/1" do
    test "returns expected value", %{input: input} do
      assert Day12.part2(input) == 525_152
    end
  end
end

ExUnit.run()
```

<!-- livebook:{"output":true} -->

```
..
Finished in 8.6 seconds (0.00s async, 8.6s sync)
2 tests, 0 failures

Randomized with seed 957866
```

<!-- livebook:{"output":true} -->

```
%{total: 2, failures: 0, excluded: 0, skipped: 0}
```

## Benchmarking

```elixir
# https://github.com/bencheeorg/benchee
Benchee.run(
  %{
    "Part 1" => fn -> Day12.part1(input) end,
    "Part 2" => fn -> Day12.part2(input) end
  },
  memory_time: 2,
  reduction_time: 2
)

nil
```

<!-- livebook:{"output":true} -->

```

```

<!-- livebook:{"output":true} -->

```
nil
```
